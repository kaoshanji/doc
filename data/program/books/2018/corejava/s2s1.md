#   流与文件

-   主要内容
    -   以二进制格式和文本格式读写文件
    -   访问文件与目录
    -   对象序列化机制
    -   Java SE 1.4版本的改进
    -   Java SE 1.7版本的改进

----

##  流

`继承结构图`

可以从目标读入一个字节序列的对象称为输入流，而可以向其中写入一个字节序列的对象称为输出流，这个目标可以是文件、网络连接或者内存块。

抽象类InputStream和OutputStream构成了输入/输出(I/O)类层次结构的基础。

因为面向字节的流不便于处理以Unicode形式存储的信息(Unicode中每个字符都使用了多个字节)，所以从抽象类Reader和Writer种继承出来一个专门用于处于Unicode字符的单独的类层次结构。这些类拥有的读入和写出操作都是基于两字节的Unicode码元，而不是基于单字节的字符。

1.  读写字节

InputStream类有一个抽象方法：`abstract int read()`，这个方法将读入一个字节，并返回读入的字节，或者在遇到结尾时返回-1，还有若干个非抽象方法，读入一个字节数组，或者跳过大量的字节

OutputStream类定义了抽象方法：`abstract void write(int b)`，向某个输出位置写出一个字节

read和write方法在执行时都将阻塞，直至字节确实被读入或写出。在这两个方法等待指定的流变为可用的这段时间里，其他线程有机会去执行有用的工作

available方法可以检测可读入的字节数量，判断大于0

当完成对流的读写时，要调用close方法关闭它，关闭一个输出流的同时还会刷新用于该输出流的缓冲区

一般不会使用某个类提供原生的read和write功能的某些具体方法，大家感兴趣的可能包含数字、字符串和对象，而不是原生字节。

Java提供了众多从基本InputStream和OutputStream类导出的类，这些类使用我们可以处理那些以常用格式表示的数据，而不只是字节。

2.  组合流过滤器

每种具体流对应一种具体的应用场景，可以通过组合不同流添加各种特性

FileInputStream和FileOutputStream提供附着在一个磁盘文件上输入流和输出流，只需向其构造器提供文件名或文件的完整路径名

DataInputStream只能读入数值类型

FileInputStream没有任何读入数值类型的方法，DataInputStream没有任何从文件中获取数据的方法

可以通过嵌套过滤器来添加多重功能

`示例`：从`文件中读入数字`，首先需要创建一个FileInputStream，然后将其传递给DataInputStream的构造器：
``` Java
FileInputStream fin = new FileInputStream("employee.dat");
DataInputStream din = new DataInputStream(fin);
double s = din.readDouble();
```

给上面示例添加`缓存机制`：
``` Java
DataInputStream din = new DataInputStream(
			new BufferedInputStream(
					new FileInputStream("employee.dat")));
// 这个构造器有点恐怖..
```

希望使用DataInputStream的方法，就放在构造器链的最后。

`示例`：从一个ZIP压缩文件中通过使用下面的流序列来读入数字：
``` Java
ZipInputStream zin = new ZipInputStream(new FileInputStream("employee.dat"));
DataInputStream din = new DataInputStream(zin);
// 怕不怕??
```

各种流根据需要组合各种情况

----

##  文本输入与输出

二进制格式的I/O高速且高效，但是不宜人来阅读。例如，整数1234存储成二进制数时，被写为由字节 00 00 04 D2构成的序列，而存储成文本格式时，存成了字符串"1234"。在存储文本字符串时，需要考虑字符编码方式，即：UTF-8、UTF-16或ISO 8849-1。

OutputStreamWriter类将使用选定的字符编码方式，把Unicode字符流转换为字节流，而InputStreamReader类将包含字节(用某种字符编码方式表示的字符)的输入流转换为可以产生Unicode码元的读入器

1.  写出文本输出

对于文本输出，可以使用 PrintWriter。
``` Java
String fileName = "employee.dat";
PrintWriter out = new PrintWriter(fileName);
out.println("kao");
out.print(123);
```

println方法在行中添加了对目标系统来说恰当的行结束符，默认情况下，自动刷新机制是禁用的，如果是自动的，只要println被调用，缓冲区中的所有字符都会被发送到他们的目的地

2.  读入文本输入

在Java SE 5.0之前，处理文本输入的唯一方式就是通过 BufferedReader类，有个readLine方法，可以读入一行文本，需要将带缓存区的读入器与输入源组合起来：
``` Java
String fileName = "employee.dat";
BufferedReader in = new BufferedReader(
        new InputStreamReader(
                new FileInputStream(fileName), "UTF-8"));

String line;
while((line = in.readLine()) != null) {
    System.out.println(line);
}
```

3.  字符集

Java SE 1.4中Java.nio包用Charset类统一对字符集的转换

字符集建立了两字节Unicode码元序列与使用本地字符编码方式的字节序列之间的映射，字符集名字是大小写不敏感的。

通过调用静态的forName方法来获得一个Charset，只需向这个方法传递一个官方名字或是他的某个别名。

一旦有了字符集，就可以使用它在包含Unicode码元的Java字符串和编码而成的字节序列之间进行转换，例如：
``` Java
Charset cset = Charset.forName(Charsets.UTF_8.name());
String str = "";
ByteBuffer buffer = cset.encode(str);
byte[] bytes = buffer.array();
```

与之相反，要想解码字节序列，需要有字节缓冲区，使用ByteBuffer数组的静态方法wrap可以将一个字节数组转换成一个字节缓冲区。decode方法的结果是一个CharBuffer，调用他的toString方法可以获得一个字符串。
``` Java
Charset cset = Charset.forName(Charsets.UTF_8.name());
byte[] bytes = null;
ByteBuffer bbuf = ByteBuffer.wrap(bytes, offset, length);
CharBuffer cbuf = cset.decode(bbuf);
String str = cbuf.toString();
```






----