#   Java IO

对于I/O操作来说，其根本的作用在于传输数据。输入和输出指的仅是数据的流向，实际传输是通过某些具体的媒介来完成的，这其中最主要的媒介是文件系统和网络连接。最早的java.io包把I/O操作抽象成数据的流动，进而有了流的概念，在Java NIO中，则把I/O操作抽象成端到端的一个数据连接，这就有了通道的概念，推荐开发人员使用Java NIO中的新的通道概念

----

##  流

不管是内存中的数据、磁盘上的数据，还是通过网络传输的数据，其基本格式都是一系列的字节，所不同的是，不同的程序对这一系列的字节有不同的解释方式。将一组字节按照特定的方式进行解释，就形成了编程语言中的不同的基本类型。

Java中最基本的流是在字节这个层次上进行操作的。也就是说基本的流只负责在来源和目的之间传输字节，并不负责对字节的含义进行解释。在基本的字节基础上，Java也提供了一些过滤流的实现，这些过滤流实际上是基本字节流上的一个封装，在其上增加了不同的处理能力，如基本类型域字节序列之间的转换等

1.  基本输入流

如果流的实现只对使用者暴露字节这个层次的细节，那么可以直接继承 InputStream 或 OutputStream类，并提供自己额外的能力。

-   输入流 InputStream 类中包含两类功能
    -   一类是与读取流中字节数据相关的功能：read方法
    -   一类是流的控制功能：close、skip等方法

2.  基本输出流

把数据从程序中输出到其他地方，基本的OutputStream类的对象也是在字节这个层次上进行操作的

-   输出流 OutputStream 类中包含两类功能
    -   写入数据的 write 方法
    -   流的控制功能：close、flush等方法

3.  输入流的复用

在很多的场景下，每个数据源仅有一个接收者，如java.net.HttpURLConnetion类的对象打开一个网络连接，得到用来读取其中数据的InputStream类的对象，但是如果有多个接收者，那么就有些复杂。主要的原因在于，从另一个方面出发，按照流本身多代表的抽象含义，数据一旦流过去，就无法被再次使用，如果直接把一个 InputStream类的对象传递给一个接收者使用之后再传递给另外一个接收者，后者不能读取到流中的任何数据，因为流的当前读取位置已经到了末尾。

数据的使用方式和数据本身有根本的区别，InputStream类表示的是数据的使用方式，而并不是数据本身，两者的根本区别在于每个InputStream类的对象作为Java虚拟机中的对象，是有其内部状态的，无法被简单的复用，而纯粹的数据本身是无状态的

-   解决需要对输入流复用的需求，基本上有两种方式：
    -   利用输入流提供的标记和重置的控制能力：BufferedInputStream
    -   把输入流转换成数据来使用：ByteArrayInputStream
-   BufferedInputStream
    -   使用内部的缓冲区提升性能
    -   提供了对标记和重置的支持
-   ByteArrayInputStream
    -   首先被写入 ByteArrayOutputStream类的对象
    -   再把得到的字节数组保存下来

4.  过滤输入输出流

在基本的输入输出流之上，java.io包还提供了多种功能更强的过滤输入输出流。这些过滤流锁提供的增强能力各部相同
-   使用了内部的缓冲区来提供读写操作时的性能
-   在基本的字节流基础上提供了读写Java基本类型的支持
-   读写Java对象的支持
-   流重复读取
-   进行文件读写操作
-   作为字节数组和流之间的桥梁
-   通过管道方式连接在一起的输入和输出流
-   把多个输入流按顺序连接起来，形成一个完整的输入流

4.  字符流

字节流主要由机器来处理，而对于用户来说，更原因看到直接可读的字符，即java.io.Reader和java.io.Writer类及其子类，字符流适合用于处理程序中包含的文本类型的内容

创建一个字符流的最常见做法是通过一个字节流InputStream类或OutputStream类的对象进行创建，对应的是InputStreamReader类和OutStreamWriter类，在从字节流转成字符流时，需要指定字符的编码格式。

----

##  缓冲区

Java中的流实现采用了一种简单而朴素的做法，即以字节流为基础，在字节流上再通过过滤流来满足不同的需要。对于开发人员来说，流加上字节数组的使用方式的抽象层次较低，使用起来比较繁琐，更好的做法是使用Java NIO中新的缓冲区实现

1.  基本用法

Java NIO中的缓冲区在某些特性上类似于Java中的基本类型的数组，区别在于缓冲区提供的功能比数组丰富，也执行存储类型异构的数据。要理解缓冲区的使用，需要理解缓冲区的3个状态变量，分别是容量、读写限制和读写位置。

-   缓冲区的容量，指的是缓冲区的额定大小，在创建时指定，无法在创建后更改，任何时候缓冲区中的数据总数都不可能超过容量。
-   读写限制，表示的是在缓冲区中进行读写操作时的最大允许位置
-   读写位置，表示的是当前进行读写操作时的位置，当在缓冲区中进行相对读写操作时，在这个位置上进行。

缓冲区同样也支持标记和重置的特性

缓冲区进行的读写操作分成两类：一类是根据当前读写位置进行的相对读写操作，另外一类是根据在缓冲区中的绝对位置进行读写操作，两者的差别在于相对读写会改变当前读写位置，而绝对对鞋则不会

2.  字节缓冲区

对于Java中的基本类型，除了布尔类型之外，都有对应的缓冲区实现，用来存储此类型的数据。

在创建 ByteBuffer类的对象时，只能通过其静态工厂方法allocate来分配新空间，或者通过wrap方式来包装一个已有的字节数组，在创建ByteBuffer类的对象时需要指定缓冲区的容量，在创建完成之后，可以通过 put 方法向缓冲区中添加数据，而get方法则从其中读取数据

由于ByteBuffer类支出对基本数据类型的处理，因此必须要考虑字节顺序，同样的字节序列按照不同的顺序去解释，所得到的结果是不同的

ByteBuffer类支持的另外一个操作时压缩，压缩操作的一个典型的应用场景是把ByteBuffer类的对象作为数据传输时的缓冲区来使用

3.  缓冲区视图

ByteBuffer类的另一个常见的使用方式是在一个已有的ByteBuffer类的对象上创建出各种不同的视图，这些视图与他所基于的ByteBuffer类的对象共享同样的存储空间，但是提供额外的实用功能。在功能上，ByteBuffer类的视图与他所基于的ByteBuffer类的对象之间的关系类似过滤流和他所包装的流的关系，正因为这种共享存储空间的特性，在视图中对数据所做的修改会反映在原始的ByteBuffer类对象中

最常见的ByteBuffer类的视图是转换成对基本数据类型进行操作的缓冲区对象

除了数据本身之外，两者的读写位置、读写限制和标记位置等都是相互独立的。

除了基本类型的缓冲区视图之外，另外一种视图是类型相同的ByteBuffer类的对象

----

##  通道




----

##  nio.2




----

##  使用案例




----