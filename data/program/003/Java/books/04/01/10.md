#   并发总结

多线程开发有两个核心问题：一个是竞争，另一个是协作。

##  线程安全的机制

线程共享内存是实现线程协作的基础，但共享内存有两个问题，竞态条件和内存可见性

-   synchronized
    -   只是一个关键字，放到类的方法声明上就可以，既可以解决竞态条件问题，也可以解决内存可见性问题
    -   他保护的是对象，而不是代码，只有对同一个对象的synchronized方法调用，synchronized才能保证他们被顺序调用
    -   对于实例方法，这个对象是this；对于静态方法，这个对象是类对象；对于代码块，需要指定那个对象
    -   synchronized不能尝试获取锁，也不响应锁，还可能会死锁
-   显式锁
    -   需要程序员自己创建锁，调用锁相关的接口，主要接口是Lock，主要实现类是ReentrantLock
    -   支持以非阻塞方式获取锁，可以响应中断，可以限时，可以指定公平性，可以解决死锁问题
    -   在读多写少，读操作可以并行的操作中，可以使用读写锁提高并发，接口是ReadWriteLock，实现类：ReentrantReadWriteLock
-   volatile
    -   如果共享的对象只有一个，操作也只是进行最简单的get/set操作，set也不依赖于之前的值，就不存在竞态条件问题，而只是内存可见性问题，在变量的声明上加上volatile就可以了
-   原子变量和CAS
    -   set的新值与原来的值有关，需要同步的代码比较简单，可以考虑原子变量
    -   对于并发环境中的计数、产生序列号等需求，考虑原子变量而不是锁
-   写时复制
    -   之所以会有线程安全的问题，是因为多个线程并发读写同一个对象，如果每个线程读写的对象都是不同的，或者，如果共享访问的对象是只读的，不能修改，那也不存在线程安全问题
-   ThreadLocal
    -   ThreadLocal就是让每个线程，对同一个变量，都有自己的独有副本，每个线程实际访问的对象都是自己的，自然就不存在线程安全问题了。

----

##  线程的协作机制

多线程之间的核心问题，除了竞争，就是协作

-   wait/notify
    -   wait/notify与synchronized配合一起使用，是线程的基本协作机制
    -   每个对象都有一把锁和两个等待队列，一个等待队列，wait将自己加入条件等待队列；另一个是条件等待对象，notify从条件等待队列上移除一个线程并唤醒
-   显式条件
    -   显式条件与显式锁配合使用
-   线程中断
    -   Java中取消/关闭一个线程的方式是中断。中断并不是强迫终止一个线程，是一种协作机制，给线程传递一个信号，线程自己判断
-   协作工具类
    -   信号量类Semaphore用于限制对资源的并发访问数
    -   倒计时门栓CountDownLatch用于不同角色线程间的同步
    -   循环栅栏CyclicBarrier用于同一角色线程间的协调一致，所有线程在到达栅栏后都需要等待其他线程，等所有线程都到达后再一起通过，他是循环，可以重复同步
-   堵塞队列
    -   常见于生产者/消费者协作模式，使用阻塞队列，阻塞队列封装了锁和条件
-   Future/FutureTask
    -   常见主从协作模式中，主线程往往是让子线程异步执行一项任务，获取其结果

----

##  容器类

线程安全的容器有两类：一类是同步容器；另一类是并发容器

-   同步容器
    -   Conllections类中有一些静态方法，可以基于普通容器返回线程安全的同步容器
-   写时复制的List和Set
    -   适用于读远多于写，集合不太大的场合
    -   以优化读曹组为目标，牺牲了写性能
-   ConcurrentHashMap
    -   ConcurrentHashMap是并发版的HashMap，读操作完全并行，写操作支持一定程度的并行
-   基于SKipList的Map和Set
    -   排序并发版本的Map和Set
-   各种队列
    -   各种阻塞队列主要用于协作，非阻塞队列适用于多个线程并发使用一个队列的场合

----

##  任务执行服务

-   基本概念
    -   任务执行服务简化了执行异步任务所需的开发，引入了一个"执行服务"的概念
    -   将"任务的提交"和"任务的执行"相分离，"执行服务"封装了任务执行的细节
-   线程池
    -   线程池主要由两个概念组成：一个是任务队列，另一个是工作者线程
    -   任务队列是一个阻塞队列，保存待执行的任务
    -   工作者线程主体就是一个循环，循环从队列中接收任务并执行
-   定时任务
    -   在Java中，有两种方式实现定时任务
    -   使用java.util包中的Timer和TimerTask
    -   使用Java并发包中的ScheduledExecutorService

----

