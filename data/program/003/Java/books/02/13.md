#   并发基础知识

在程序中创建线程来启动多条执行流。

##  线程的基本概念

Java线程的一些基本概念，包括创建线程、线程的基本属性和方法、共享内存及问题、线程的优点及成本。

线程表示一条单独的执行流，他有自己的程序执行计数器，有自己的栈。

创建线程的方式：
-   继承Thread
-   实现Runnable接口

top.kaoshanji.example.javaProgramming.ss19.HelloThread

top.kaoshanji.example.javaProgramming.ss19.HelloRunnable

创建继承/实现类的对象，调用start方法，表示启动该线程，使其成为一条单独的执行流

线程的基本属性和方法：
-   id：一个递增的整数，每创建一个线程就加一
-   name：默认值是 Thread- 后跟一个编号，可以在构造方法中进行指定
-   优先级：映射到操作系统中相同的优先级，编程时，不要过于依赖优先级
-   状态：一个枚举类型
-   是否daemo线程
-   sleep方法
-   yield方法
-   join方法

竞态条件：当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确
内存可见性：多个线程可以共享访问和操作相同的变量，但一个线程对一个共享变量的修改，另一个线程不一定马上就能看到，甚至永远也看不见

在计算机系统中，除了内存，数据还会被缓存在CPU的寄存器以及各级缓存中，当访问一个变量时，可能直接从寄存器或CPU缓存中读取，而不一定到内存中去取，当修改一个变量时，也可能是先写到缓存中，稍后才会同步更新到内存中

优点及成本：
-   充分利用多CPU的计算能力，多线程可以利用多CPU的计算能力
-   充分利用硬件资源，CPU和硬盘、网络是可以同时工作的，一个线程在等待网络IO的同时，另一个线程完全可以利用CPU，对于多个独立的网络请求，完全可以使用多个线程同时请求。
-   在用户界面(GUI)应用程序中，保持程序的响应性，界面和后台任务通常是不同的线程
-   简化建模及IO处理，比如，在服务器应用程序中，对每个用户请求使用一个单独的线程进行处理，相比使用一个线程，处理来自各种用户的各种请求，以及各种网络和文件IO事件，建模和编写程序要容易得多

----

##  理解synchronized

共享内存有两个重要问题，一个是竞态条件，另一个是内存可见性，解决这两个问题的一个方案是使用synchronized关键字。

synchronized可以用于修饰类的实例方法、静态方法和代码库

看起来，synchronized使得同时只能有一个线程执行实例方法，但这个理解是不确切的。多个线程是可以同时执行同一个synchronized实例方法的，只要他们访问的对象时不同的即可。

synchronized实例方法保护的是同一个对象的方法调用，确保同时只能有一个线程执行。synchronized实例方法保护的是当前实例对象，即this，this对象有一个锁和一等等待队列，锁只能被一个线程持有，其他试图获得同样锁的线程需要等待

过程：
-   尝试获得锁，如果能够获得锁，继续下一步，否则加入等待队列，阻塞并等待唤醒
-   执行实例方法体代码
-   释放锁，如果等待队列上有等待的线程，从中取一个并唤醒，如果有多个等待的线程，唤醒哪一个不一定，不保证公平性

synchronized保护的是对象而非代码，只要访问的是同一个对象的synchronized方法，即使是不同的代码，也会被同步顺序访问

synchronized方法不能防止非synchronized方法被同时执行

特点：
-   可重入性
    -   对同一个执行线程，他在获得锁之后，在调用其他需要同样锁的代码时，可以直接调用，比如，在一个synchronized实例方法内，可以直接调用其他synchronized实例方法
-   内存可见性
    -   保证内存可见性，在释放锁时，所有写入都会写回内存，而获得锁后，都会从内存中读最新数据
-   死锁
    -   尽量避免在持有一个锁的同时去申请另一个锁
    -   如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁

----

##  线程的基本协作机制

多线程协作的基本机制：wait/notify

场景：
-   生产者/消费者：生产者线程和消费者线程通过共享队列进行协作，生产者将数据或任务放到队列上，而消费者从队列上取数据或任务。
-   同时开始：类似运动员比赛，在听到比赛开始枪响后同时开始
-   等待结束：主从模式，主线程将任务分解为若干子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前需要等待每个子任务执行完毕
-   异步结果：主从模式，将子线程的管理封装为异步调用，异步调用马上返回，但返回的不是最终的结果，而是一个一般称为Future的对象，通过他可以在随后获得最终的结果
-   集合点：类似学校或公司组团旅游，在旅游过程中有若干集合点，比如出发集合点，每个人从不同地方来到集合点，所有人都到齐后进行下一项活动

除了用于锁的等待队列，每个对象还有另一个等待队列，表示条件队列，该队列用于线程间的协作。调用wait就会把当前线程放到条件队列上并阻塞，表示当前线程执行不下去了，他需要等待一个条件，这个条件他自己改变不了，需要等待线程改变。notify做的事情就是从条件队列中选一个线程，将其从队列中移除并唤醒，notifyAll和notify的区别是，他会移除条件队列中所有的线程并全部唤醒

wait/notify方法只能在synchronized代码块内被调用

wait/notify方法，他们被不同的线程调用，但共享相同的锁和条件等待队列，他们围绕一个共享的条件变量进行协作，这个条件变量是程序自己维护的，当条件不成立时，线程调用wait进入条件等待队列，另一个线程修改了条件变量后调用notify，调用wait的线程唤醒后需要重新检查条件变量

从多线程的角度看，他们围绕共享变量进行协作，从调用wait的线程角度看，他阻塞等待一个条件的成立。

----

##  线程的中断

场景：
-   很多线程的运行模式是死循环，比如生产者/消费者模式中，消费者主体就是一个死循环，他不停的从队列中接受任务，执行任务，在停止程序时，需要一种"优雅"的方式以关闭该线程
-   在一些图形用户界面程序中，线程是用户启动的，用户可能会希望取消该任务
-   在一些场景中，比如从第三方服务器查询一个结果，希望在限定的时间内得到结果，如果得不到，希望取消该任务
-   启动多个线程做同一件事，类似抢火车票，多人抢，但是只要一张即可

在Java中，停止一个线程的主要机制是中断，中断并不是强迫终止一个线程，他是一种协作机制，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出

----