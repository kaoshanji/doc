#   共享数据

##  事务和并发控制

事务和并发控制在服务器管理共享对象时的应用。

事务定义了一个服务器操作序列，由服务器保证这些操作序列在多个客户并发访问和服务器出现故障情况下的原子性。

嵌套事务定义了若干事务之间的嵌套结构，它们因为具有更高的并发度，因而在分布式系统中非常有用。

所有的并发控制协议都是基于串行相等的标准，它们都源于用来解决冲突的规则。

### 简介

事务的目标是在多个事务访问对象以及服务器面临故障的情况下，保证所有由服务器管理的对象始终保持一个一致的状态。

事务是由客户定义的针对服务器对象的一组操作，他们组成一个不可分割的单元，由服务器执行。服务器必须保证或整个事务被执行并将执行结果记录到持久存储中，或者在出现故障时，能完全消除这些操作的所有影响。

-   简单的同步机制(无事务)

如果不仔细设计服务器，不同客户执行的操作有时会相互冲突。这种冲突会导致对象产生不正确的值。

服务器上的原子操作：对象应该设计成支持多线程的上下文环境。

通过服务器操作的同步加强客户协同：客户可以将服务器作为一种共享资源的设施

-   事务的故障模型


### 事务

事务起源于数据库管理系统，数据库管理系统中的事务是访问数据库的一个程序的执行。

事务后来被引入分布式系统、分布式对象系统中。

-   并发控制
-   事务放弃时的恢复

服务器必须保证事务被放弃后，他的更新作用完全取消，而不影响其他并发事务。

### 嵌套事务

嵌套事务允许事务由其他事务构成，这样，从一个事务内可以发起几个事务，从而能够将事务看成按需组成的模块。

嵌套事务的最外层事务称为顶层事务，除顶层事务之外的其他事务称为子事务。

### 锁

事务必须通过调度使他们对共享数据的执行效果是串行等价的。服务器可以通过串行化对象访问来达到事务的串行等价。

一个简单的串行化机制是使用互斥锁。在这种锁机制下，服务器试图给客户事务操作所访问的对象加锁。如果客户请求访问的一个对象已被其他客户的事务锁住，那么服务器将暂时挂起这个请求，直到对象被解锁。

-   死锁

两个事务都在等待并且只有对方释放锁后才能继续执行。

死锁的定义：死锁是一种状态，在该状态下一组事务中的每一个事务都在等待其他事务释放某个锁。

预防死锁：让每个事务在开始运行时就锁住他要访问的所有对象。

更新锁

死锁检测：通过寻找等待图中的环路可以检测死锁。

超时：每个锁都有一个时间期限，一旦超过这个期限，锁将成为可剥夺的。

-   在加锁机制上增加并发度

增加并发度的空间，讨论两种已被使用的方法，第一种方法(双版本加锁)中，互斥锁的设置推迟到事务提交时才进行，第二种方法(层次锁)中，使用混合粒度的锁。

双版本加锁：这是一种乐观策略，他允许一个事务针对对象的临时版本进行写操作，而其他的事务读取同一对象提交后的版本，读操作只在其他事务正在提交同一个对象时才等待。

层次锁：对于某些应用，适合一个操作的锁粒度不一定适合另一个操作。混合粒度的锁允许每个事务按其需要锁住部分数据，一个访问大量对象的长事务可能需要锁住整个系统，而一个短事务只需锁住细粒度的数据。

### 乐观并发控制

串行化事务的乐观方法来避免锁机制的缺点。

在大多数应用中，两个客户事务访问同一个对象的可能性是很低的，事务总是能够执行，就好像事务之间不存在冲突一样。

事后的验证

向后验证

向前验证

### 时间戳排序

在基于时间戳排序的并发控制机制中，事务中的每一个操作在执行之前要先进行验证。如果该操作不能通过验证，那么事务将被立即放弃，然后由客户重新启动该事务。每个事务在启动时被赋予一个唯一的时间戳，这个时间戳定义了该事务在事务序列中的位置，来自不同事务的操作请求可以根据他们的时间戳进行全排序。

### 并发控制方法的比较


##  分布式事务

分布式事务即涉及多个服务器的事务，可以是平面事务，也可以是嵌套事务。

原子提交协议是参与分布式事务的服务器所使用的一个协作过程，它使多个服务器能共同决策是提交事务还是放弃事务。

### 简介

访问由多个服务器管理的对象的平面事务或嵌套事务称为分布式事务。

当一个分布式事务结束时，事务的原子特性要求所有参与该事务的服务器必须全部提交或全部放弃该事务。为了实现这一点，其中一个服务器承担了协调者的角色，由他来保证在所有的服务器上获得同样的结果。

事务恢复用于保证事务所涉及的所有对象都是可恢复的。

### 平面分布式事务和嵌套分布式事务

如果客户事务调用了不同服务器上的操作，那么他就是一个分布式事务。

在平面事务中，客户给多个服务器发送请求。

在嵌套事务中，顶层事务可以创建子事务，子事务可以进一步的以任意深度嵌套子事务。

-   分布式事务的协调者

执行分布式事务请求的服务器需要相互通信，以确保在事务提交时能够协调他们之间的动作。

创建某一分布式事务的协调者成为该分布式事务的协调者，他在分布式事务结束时负责提交或放弃事务。管理分布式事务访问的对象的每个服务器都是该事务的参与者，每个服务器提供一个我们称为参与者的对象。

### 原子提交协议

事务的原子性要求分布式事务结束时，他的所有操作要么全部执行，要么全部不执行。

两阶段提交协议的设计出发点是允许任何一个参与者自行放弃他自己的那部分事务。

在第一阶段，每个参与者投票表决事务是放弃还是提交。

在第二阶段，事务的每个参与者执行最终统一的决定。如果任何一个参与者投票放弃事务，那么最终的决定将是放弃事务。

-   两阶段提交协议

在两阶段提交协议的第一阶段，协调者询问所有的参与者是否准备好提交，在第二阶段，协调者通知他们提交(或放弃)事务。

两阶段提交协议由投票阶段和完成阶段组成。

-   嵌套事务的两阶段提交协议

当子事务执行完毕时，他独立决定是临时提交还是放弃。

当顶层事务完成后，他的协调者将执行两阶段提交协议。

### 分布式事务的并发控制

每个服务器要管理很多对象，他必须保证在并发事务访问这些对象时，这些对象仍然保持一致性。因此，每个服务器需要对自己的对象应用并发控制机制。

分布式事务中所有服务器共同保证事务以串行等价方式执行。

-   加锁

在分布式事务中，某个对象的锁总是本地特有的(在同一个服务器中)。是否加锁是由本地锁管理器决定的，本地管理器决定是满足客户对锁的请求，还是让发出请求的事务等待。

-   时间戳并发控制

对于单服务器事务，协调者在他开始运行时分配一个唯一的时间戳。通过按访问对象的事务的时间戳次序提交对象的版本来保证串行等价性。在分布式事务中，协调者必须保证每个事务附上全局唯一的时间戳。

全局唯一的时间戳由事务访问的第一个协调者发送给客户。

-   乐观并发控制

在乐观并发事务控制中，每个事务在提交之前必须首先进行验证。事务在验证开始时首先要附加一个事务号，事务的串行化是根据这些事务号的顺序实现的。

分布式事务的验证由一组独立的服务器共同完成，每个服务器验证访问自己对象的事务。这些验证在两阶段协议的第一个阶段进行。

### 分布式死锁

分布式死锁的检查要求在分布于多个服务器上的全局等待图中寻找环路。

每个服务器都构造出全局等待图的一部分，因此，各服务器之间通过通信才能发现图中的环路。

假死锁：如果"检测出"的死锁并非真正的死锁，那么这个死锁被称为"假死锁"。

边追逐方法：服务器通过转发探询消息来发现环路，这些探询消息沿着分布式消息的图的边发送。一个探询消息包含全局等待图中表示路径的一个事务等待关系。

事务优先级


### 事务恢复

事务恢复就是保证服务器上对象的持久性并保证服务提供故障原子性。

-   日志

在日志技术中，恢复文件包含该服务器执行的所有事务的历史。该历史由对象值、事务状态和意图列表组成。

日志中的次序反映了服务器上事务准备好、已提交或已放弃的顺序。恢复文件将包含服务器上所有对象的值得一个最近快照，随后存放该快照后的事务历史。

-   影子版本

影子版本利用一个映射来定位在版本存储文件中的某个对象版本。这个映射将对象标识符和对象当前版本在版本存储中的位置对应起来。每个事务写入的版本均是前面提交版本的影子版本。

-   为何恢复文件需要事务状态和意图列表

-   两阶段提交协议的恢复

##  复制

在分布式系统中，复制是提供高可用性和容错的关键技术。

### 简介

数据的复制，即如何在多个计算机中进行数据副本的维护。

复制是一种增强服务的技术，进行复制的动机包括改善服务性能，提高可用性或者增强容错能力。

### 系统模型和组通信的作用

系统中的数据是由对象集合组成的。一个"对象"可以是一个文件、或者是一个Java对象。

每个这样的逻辑对象是由若干称为副本的物理拷贝组成的集合实现。

-   系统模型

从一般性方面考虑，体系结构组件是通过其作用来描述的。

模型中的副本由不同的副本管理器来管理。副本管理器是包含了特定计算机上的副本，并且直接操作这些副本的组件。

副本管理器的集合可以是静态的，也可以是动态的。

-   组通信的作用

### 容错服务

在副本管理器上复制数据和功能来提供容错服务，即使有至多f个进程出故障还能正确的服务。

-   被动(主备份)复制

在用于容错的被动或主备份复制模型中，任何时候都有一个主副本管理器和一个或多个次备份副本管理器，他们称为"备份"或"从管理器"。该模型的实质是，前端只和主副本管理器通信以获得服务。

主副本管理器执行操作并将更新操作的副本发送到备份副本管理器。

-   主动复制

在用于容错的主动复制模型中，副本管理器是一个状态机，其中每个副本管理器充当同等的角色并被组织成一个组。

### 高可用服务的实例研究：闲聊体系结构、Bayou和Coda

-   闲聊体系结构
-   Bayou 系统和操作变换方法
-   Coda 文件系统

### 复制数据上的事务

每个副本管理器为他自己的对象提供并发控制和恢复。

-   复制事务的体系结构

-   可用拷贝复制

-   网络分区

-   待验证的可用拷贝

-   法定数共识方法

-   虚拟分区算法

----

有点复杂。。不懂