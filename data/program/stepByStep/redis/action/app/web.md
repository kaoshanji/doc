#   web应用

从高层次的角度来看，web应用就是通过HTTP协议对网页浏览器发送的请求进行相应的服务器或者服务，服务器本身不会记录与过往请求有关的任何信息。

通过将传统数据库的一部分数据处理任务以及存储任务转交给Redis来完成，可以提升网页的载入速度，并降低资源的占用量。


##  登录cookie

-   用户基本信息 

使用`一个散列来存储登录cookie令牌与已登录用户之间的映射`，要检查一个用户是否已经登录，需要根据给定的令牌来查找与之对应的用户，并在用户已经登录的情况下，返回该用户的ID。

-   用户最近登录会话

用户每次浏览页面的时候，程序都会对用户存储在登录散列里面的信息进行更新，并将用户的令牌和当前时间戳添加到`记录最近登录用户的有序集合`里面。

为了限制会话数据的数量，只保存最新的1000万个会话，并清理旧会话。

-   某用户最新浏览的商品

如果用户正在浏览的是一个商品页面，程序还会将这个商品添加到`记录这个用户最近浏览过的商品的有序集合`里面，并在被记录商品数量超过25个时，对这个有序集合进行修剪

-   清理过期数据

保留最新1000万个会话。

如果有序集合的大小超过了限制，那么程序移除最多100个最旧的令牌，并从记录用户登录信息的散列里面，移除被删除令牌对应的用户信息，清理存储了这些用户最近浏览商品记录的集合

清理购物车数据

当正在删除这个用户，而这个用户又在登录，就出现了竞争。

----

##  购物车cookie

用户ID同样用在购物车上，保存一致。

每个用户的购物车都是一个散列，这个散列存储了商品ID与商品订购数量之间的映射。

对商品数量进行验证的工作由Web应用程序负责，当商品的订购数量发生变化时，对购物车进行更新

当用户订购商品的数量大于0，将这件商品的ID以及用户订购该商品的数量添加到散列里面，如果以及存在，就覆盖

如果小于0，那么程序就移除该条目


----

##  缓存生成的网页：经常不变的数据

网站上面的多数页面实际上并不会经常发生大的变化，在一般情况下，网站只有账号设置、以往订单、购物车以及其他少数几个页面才包含需要每次载入都要动态生成的内容

减少网站在动态生成内容上面所花的时间，可以降低网页处理相同负载所需的服务器数量，并让网站的速度变得更快

web框架在处理请求之前或之后添加额外的功能。对于一个不能被缓存的请求，函数将直接生成并返回页面，而对于可以被缓存的请求，首先尝试从缓存里面取出并返回被缓存的页面，如果页面不存在，那么函数会生成页面并将其缓存在Redis里面5分钟，最后再将页面返回给函数调用者

缓存函数可以让网站5分钟之内无需再为他们动态的生成视图页面，访问页面延迟值等于查询一次Redis所需的时间

----

##  缓存数据库行：经常变化

为了清空旧库存和吸引客户消费，决定开始新一轮的促销活动：这个活动每天都会推出一些特价商品供用户抢购。所有特价商品的数量都是有限的，卖完即止。这样的话，就不能对整个促销页面进行缓存，数据有可能过时。

为了应对促销活动带来的大量负载，需要对数据进行缓存，具体的做法是：编写一个持续运行的守护函数，让这个函数将指定的数据行缓存到Redis里面，并不定期的对这些缓存进行更新。





----

##  分析网页访问记录



----