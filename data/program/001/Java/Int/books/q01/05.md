#   继承

利用继承，可以基于已存在的类构建一个新类。继承已存在的类就是复用(继承)这些类的方法和域。在此基础上，可以添加一些新的方法和域，以满足新的需求。

反射是指在程序运行期间发现更多的类及其属性的能力。

##  类、超类和子类

关键字extends表明正在构建的新类派生于一个已存在的类。已存在的类称为超类，新类称为子类。子类比超类拥有的功能更加丰富。

在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。

超类中的有些方法对子类并不一定适用，需要提供一个新的方法来覆盖超类中的方法，调用超类同名方法适用关键词 super

一个对象变量可以指示多种实际类型的现象称为多态，在运行时能够自动地选择调用那个方法的现象称为动态绑定

继承并不仅限于一个层次，由一个公共超类派生出来的所有类的集合被称为继承层次。在继承层次中，从某个特定的类到祖先的路径被称为该类的继承链

有一个用来判断是否应该设计为继承关系的简单规则，这就是"is-a"规则，他表明子类的每个对象也是超类的对象。

不允许扩展的类称为final类。

将方法或类声明为final主要目的是：确保他们不会在子类中改变语义

将一个类型强制转换成另外一个类型的过程被称为类型转换，进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能

如果自下而上在类的继承层次结构中上移，位于上层的类更具有通用性，甚至可能更加抽象。从某种角度看，祖先类更加通用，只是将他作为派生其他类的基类，而不作为想使用的实例类。为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。

除了抽象方法之外，抽象类还可以包含具体数据和具体方法。抽象方法充当着占位的角色，他们的具体实现在子类中。扩展抽象类可以有两种选择：一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。

类即使不含抽象方法，也可以将类声明为抽象类

抽象类不能被实例化

有些时候，希望超类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域，为此，需要将这些方法或与声明为protected。

----

##  Object：所有类的超类

Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来

在Java中，只有基本类型不是对象，例如，数值、字符和布尔类型的值都不是对象

所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类

Object类中的equals方法用于检测一个对象是否等于另外一个对象。在Object类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，他们一定是相等的。

散列码是由对象导出的一个整型值，没有规律。定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。

如果重新定义equals方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散列表中。

hashCode方法应该返回一个整型数值(也可以是负数)，并合理的组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀。

toString方法用于返回表示对象值得字符串，用来打印输出对象所属的类名和散列码

----

##  泛型数组列表

ArrayList类具有自动调节数组容量的功能，是一个采用类型参数的泛型类，为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面。使用add方法可以将元素添加到数组列表中，如果调用add且内部数组已经满了，数组列表就将自动创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。

如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用ensureCapacity方法

一旦能够确认数组列表的大小不再发生变化，就可以调用trimToSize方法，这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目，垃圾回收器将回收多余的存储空间。

----

##  枚举类

定义枚举类型：
```
public enuni Size { SMALL , MEDIUM , LARGE , EXTRAJARGE } ;
```

这个声明定义的类型是一个类，他刚好有4个实例。

如果需要的话，可以在枚举类型中添加一些构造器、方法和域，当然，构造器只是在构造枚举常量的时候被调用

所有的枚举类型都是 Enum类的子类。

----

##  反射

反射库提供了一个非常丰富且精心设计的工具集，以便编写能够动态操作Java代码的程序。

能够分析类能力的程序称为反射。
-   在运行时分析类的能力
-   在运行时查看对象
-   实现通用的数组操作代码
-   利用Method对象

在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。

可以通哟专门的Java类访问这些信息，保存这些信息的类被称为Class。一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。

虚拟机为每个类型管理一个Class对象，因此，可以利用 == 运算符实现两个类对象比较的操作

还有一个很有用的方法 newInstance()，可以用来动态的创建一个类的实例，他调用默认的构造器初始化新创建的对象

将forName与newInstance配合起来使用，可以根据存储在字符串中的类名床架一个对象。

在 java.lang.reflect 包中有三个类 Field、Method和Constructor 分别用于描述类的域、方法和构造器。

Class 类中的 getFields、 getMethods 和 getConstructors 方法将分别返回类提供的public 域、方法和构造器数组，其中包括超类的公有成员

Class 类的 getDeclareFields、getDeclareMethods 和 getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员。

----

##  继承的设计技巧

-   将公共操作和域放在超类
-   不要使用受保护的域
-   使用继承实现"is-a"关系
-   除非所有继承的方法都有意义，否则不要使用继承
-   在覆盖方法时，不要改变预期的行为
-   使用多态，而非类型信息
-   不要过多的使用反射

----