# 第17章：有关事务的楔子


##  1、认识事务本身

事务的目的：对于一个软件系统来说，需要相应的数据资源(如：数据库、文件系统等)来保存系统状态。对在系统状态所依托的数据资源进行访问的时候，为了保证系统始终处于"正确"的状态，必须对这些访问操作进行一些必要的限定，以此保证系统状态的完整性。

事务就是以可控的方式对数据资源进行访问的一组操作。为了保证事务执行前后，数据资源所承载的系统状态始终处于"正确"状态，事务本身持有4个限定属性：原子性、一致性、隔离性和持久性，也就是ACID属性。

1.  原子性

原子性要求事务所包含的全部操作是一个不可分割的整体，这些操作要么全部提交成功，要么只要其中一个操作失败，就全部失败。

2.  一致性

一致性要求事务所包含的操作不能违反数据资源的一致性检查，数据资源在事务执行之前处于某个数据一致性状态，那么，事务执行之后也依然需要保持数据间的一致性状态。比如转账前后，总额是一致的。

3.  隔离性

事务的隔离性主要规定了各个事务之间相互影响的程度。隔离性概念主要面向对数据资源的并发访问，并兼顾影响事务的一致性。当两个事务或更多事务同时访问一个数据资源的时候，不同的隔离级别决定了各个事务对该数据资源访问的不同行为。

- Read Uncommitted(读未提交)，他是最低级别，一个事务可以读取另一个事务没有提交的更新结果，具有较高的性能，但是，有以下问题
  - 脏读：如果一个事务对数据进行了更新，但事务还没有提交，另一个事务就可以"看到"该事务没有提交的更新结果。这样造成的问题就是，如果第一个事务回滚，那么第二个事务再次之前所"看到"的数据就是一笔脏数据。
  - 不可重复读：指同一个事务在整个过程中对同一笔数据进行读取，每次读取结果不同。如果事务1在事务2的更新之前读取一次数据，在事务2的更新操作之后再读取同一笔数据一次，两次结果是不同的。
  - 幻读：指同样一个查询在整个事务过程中多次执行后，查询所得的结果集是不一样的，幻读针对的是多笔记录。不管事务2的插入操作是否提交，事务1在插入操作之前和之后执行相同的查询，取得的结果集是不同的。
- Read Committed(读已提交)，是大部分数据库采用的默认隔离级别，他比Read Uncommitted隔离级别拥有更高级别的限定。在该隔离级别下，一个事务的更新操作结果只有在该事务提交之后，另一个事务才可能读取到同一笔数据更新后的结果，可以避免脏读，但是不能避免不可重复读和幻读的问题
- Repeatable Read(重复读)，可以保证在整个事务的过程中，对同一笔数据的读取结果是相同的，不管其他事务是否同时在对同一笔数据进行更新，也不管其他事务对同一笔数据的更新提交与否，可以解决脏读和不可重复读取的问题，但是不能避免幻读
- Serializable(序列)，最为严格的隔离级别，所有的事务操作都必须依次顺序执行，可以避免其他隔离级别遇到的所有问题，是最为安全的隔离级别，但同时也是性能最差的隔离级别。

不同的隔离级别设置会对系统的并发性以及数据一致性造成不同的影响，总得来说，隔离级别与系统并发性成反比，与数据一致性成正比。

4.  持久性

事务的持久性是指，一旦整个事务操作成功提交，对数据所做的变更将被记载并不可逆转。

##  2、认识事务家族成员

- 在一个典型的事务处理场景中，有以下几个参与者：
  - Resource Manager，简称RM，负责存储并管理系统数据资源的状态，比如数据库服务器、JMS消息服务器等。
  - Transaction Procession Monitor，简称TPM或TP Monitor，他的职责是在分布式事务场景中协调多个RM的事务处理，TPM通常对应特定的软件中间件。
  - Transaction Manager，简称TM，可以认为是TPM中的核心模块，直接负责多RM之间事务处理的协调工作，并且提供事务界定、事务上下文传播等功能接口
  - Application，以独立形式存在的或运行于容器中的应用程序，可以认为是事务边界的出发点。


根据整个事务中涉及的RM得多寡来区分事务类型，可以分为两类，即全局事务和局部事务。

`全局事务`：如果整个事务处理过程中有多个RM参与，就需要引入TPM来协调多个RM之间的事务处理，这种场景下的事务，成为全局事务或分布式事务。

`局部事务`：如果当前事务只有一个RM参与其中，就是局部事务。

----